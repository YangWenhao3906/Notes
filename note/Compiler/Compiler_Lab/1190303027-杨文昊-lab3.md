

<div align = "center"><span style='font-size:30px;font-family:宋体;'>2022年春季学期</span></div>

<div align = "center"><span style='font-size:30px;font-family:宋体;'>哈尔滨工业大学计算学部</span></div>

<div align = "center"><span style='font-size:30px;font-family:宋体;'>《编译原理》课程</span></div>



<div align = "center"><span style='font-size:32px;font-family:宋体;'>Lab3 实验报告</span></div>







<span style='font-size:20px;font-family:宋体;'>目录</span>

[TOC]



| 姓名     | 杨文昊           |
| -------- | ---------------- |
| 学号     | 1190303027       |
| 班号     | 1903202          |
| 电子邮件 | 675451361@qq.com |
| 手机号码 | 15855161066      |

<div STYLE="page-break-after: always;"></div>

## 总流程

```c
//语法分析
yyparse();
if(errorCount==0){
    //语义分析+中间代码生成+一些小的优化
    initTable();
    Program(root);
    //代码优化
    deleteLabel();
    figure_const();	
	//输出
    if(argc<=2)	return 1;
    fwriteAllCode(argv[2]);
}
```

- 在语义分析的过程中, 进行中间代码生成, 并做一些小的优化

- 在翻译时，并不会一边翻译一边输出代码内容，而是将解析好的中间代码插入到先前定义好的数据结构中。等完全解析完毕后再一并输出，从而增加了代码的可优化性。



## 线形IR实现

### 双向链表与中间代码可能类型的定义

- 采用的是`双向链表`
  - 定义了 `pre` 和 `next` 两个分别指向前后的指针:

```c
InterCode pre,next;
```

- 枚举了中间代码的可能类型:
  - 实验中将操作数分为若⼲类，种类较多不⼀⼀列举：

- 将所有的变量均采用`编号`的方式进行保存: 
  - 由于源代码中可能出现以下划线开头的变量名, 故将所有的变量均采用`编号`的方式进行保存。 
  - 同时这种⽅式也为后续`数据流分析`提供了便利，便于在转移⽅程和控制流函数计算时变量名与向量索引的映射

```c
union{
		int var_no;		
		char* value;	
		Operand name;  
	}u;
```

### 接口

```c
void insertCode(InterCode c);
void deleteCode(InterCode c);
void fwriteAllCode(char *fname);
void fwriteOp(Operand op,FILE *fp);
```



## [亮点]选做1: 结构体与一维数组地址计算

`typeSize()函数`

- 功能: 实现了结构体和⼀维数组的地址计算
- 参数: type
- 报错: 如遇到高维数组，则会报错无法translate

结构体结构如下: 

- 指针不断后移, 找到链表尾部即可, 
- 在过程中`累加`计算偏移量

![image-20220415200034896](images/1190303027-%E6%9D%A8%E6%96%87%E6%98%8A-lab3/image-20220415200034896.png)



## [亮点]代码优化

### [亮点]赋值语句优化: 不生成不必要的临时变量

对于赋值语句: 不生成不必要的临时变量

**以`测试用例1`为例:**

**我生成的中间代码:**

```asm
FUNCTION	main	:
READ	n	
```

**指导书上的中间代码:**

```asm
FUNCTION	main	:
READ	t1
v1   :=   t1
```

此处没有生成临时变量`t1`, 因为进行了如下判断, 若满足以下条件, 临时变量即可直接被代替

- 右值类型为`TEMPVAR`
- 右值是"没必要的": 我用了一个var_no表示实际需不需要另起一个变量进行存储
- 左值为`TEMPVAR`或者`VARIABLE`

```c
if(rightOp->kind==TEMPVAR && rightOp->u.var_no==temp_no && (leftOp->kind==TEMPVAR||leftOp->kind==VARIABLE) )
					memcpy(rightOp,leftOp,sizeof(struct Operand_));
```

### [亮点]消除冗余的label

**功能**: 将没有GOTO语句或者IF_GOTO语句指向的Label删去，并且把连续的label合并

**函数**: `deleteLabel()`

```
LABEL label1
LABEL label3
LABEL label5
...
```

此时只需要保留第一个label即可，并把需要删除的label全替换为保留的label即可

### [亮点]计算常数运算并替换常数

**功能**: 将常数之间的运算计算出来, 如果存储结果的是⼀个临时变量, 则将该临时变量直接替换为该结果常数

**函数**： `figure_const` 

```
t3 := #1
WRITE t3
```

转化为

```
WRITE #1
```



## 编译与运行

- 编译: 在代码目录, 命令行输入`make`即可
- 运行: 命令行输入`make test1.cmm`即可

